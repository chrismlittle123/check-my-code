/**
 * E2E tests for `cmc generate` command
 */

import { describe, it, expect, afterEach } from "vitest";
import { readFile, writeFile } from "fs/promises";
import { join } from "path";
import { run } from "./runner.js";

const PROJECTS_DIR = join(process.cwd(), "tests", "e2e", "projects");

describe("cmc generate eslint", () => {
  it("generates valid ESLint config with --stdout", async () => {
    const result = await run("check/typescript/default", [
      "generate",
      "eslint",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("// Generated by cmc (check-my-code)");
    expect(result.stdout).toContain("import js from '@eslint/js'");
    expect(result.stdout).toContain("tseslint.config(");
  });

  it("includes rules from cmc.toml", async () => {
    const result = await run("check/typescript/default", [
      "generate",
      "eslint",
      "--stdout",
    ]);

    expect(result.stdout).toContain('"no-var": "error"');
    expect(result.stdout).toContain('"prefer-const": "error"');
    expect(result.stdout).toContain('"eqeqeq"');
  });

  it("generates complete ESLint config structure", async () => {
    // Use --stdout to avoid file system side effects
    const result = await run("check/typescript/default", [
      "generate",
      "eslint",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("export default");
    expect(result.stdout).toContain("tseslint.config(");
    expect(result.stdout).toContain("rules:");
  });
});

describe("cmc generate ruff", () => {
  it("generates valid Ruff config with --stdout", async () => {
    const result = await run("check/typescript/default", [
      "generate",
      "ruff",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("# Generated by cmc (check-my-code)");
    expect(result.stdout).toContain("line-length = 100");
    expect(result.stdout).toContain("[lint]");
  });

  it("includes lint rules from cmc.toml", async () => {
    const result = await run("check/typescript/default", [
      "generate",
      "ruff",
      "--stdout",
    ]);

    expect(result.stdout).toContain('select = ["E","F","I"]');
    expect(result.stdout).toContain('ignore = ["E501"]');
  });
});

describe("cmc generate - error handling", () => {
  it("fails with exit code 3 for unknown linter", async () => {
    const result = await run("check/typescript/default", [
      "generate",
      "unknown",
    ]);

    expect(result.exitCode).toBe(3);
    expect(result.stderr).toContain("Unknown linter");
  });

  it("is case insensitive for linter name", async () => {
    const result = await run("check/typescript/default", [
      "generate",
      "ESLINT",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("// Generated by cmc");
  });
});

describe("cmc generate - --force flag", () => {
  // Original content to restore after tests that modify files
  const forceOverwriteDir = join(PROJECTS_DIR, "generate", "force-overwrite");
  const eslintOriginal = `// OLD CONFIG - should be overwritten by --force
// This is intentionally out of date

export default {};
`;
  const ruffOriginal = `# OLD CONFIG - should be overwritten by --force
# This is intentionally out of date

line-length = 80
`;

  afterEach(async () => {
    // Restore original files after each test that uses force-overwrite project
    await writeFile(
      join(forceOverwriteDir, "eslint.config.js"),
      eslintOriginal,
    );
    await writeFile(join(forceOverwriteDir, "ruff.toml"), ruffOriginal);
  });

  it("fails when ESLint config exists without --force", async () => {
    const result = await run("generate/existing-config", [
      "generate",
      "eslint",
    ]);

    expect(result.exitCode).toBe(2);
    expect(result.stderr).toContain("already exists");
  });

  it("fails when Ruff config exists without --force", async () => {
    const result = await run("generate/existing-config", ["generate", "ruff"]);

    expect(result.exitCode).toBe(2);
    expect(result.stderr).toContain("already exists");
  });

  it("can generate ESLint config with --stdout when config exists", async () => {
    // Use --stdout to avoid file system side effects
    const result = await run("generate/existing-config", [
      "generate",
      "eslint",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("// Generated by cmc");
  });

  it("generates config with --stdout even when config exists", async () => {
    // Using --stdout avoids file system side effects
    const result = await run("generate/fresh", [
      "generate",
      "eslint",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("// Generated by cmc");
  });

  it("--stdout bypasses file existence check", async () => {
    const result = await run("generate/existing-config", [
      "generate",
      "eslint",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("// Generated by cmc");
  });

  it("overwrites ESLint config when --force is used", async () => {
    // Verify original file has old content
    const eslintPath = join(forceOverwriteDir, "eslint.config.js");
    const originalContent = await readFile(eslintPath, "utf-8");
    expect(originalContent).toContain("OLD CONFIG");
    expect(originalContent).not.toContain('"no-var"');

    // Run generate with --force
    const result = await run("generate/force-overwrite", [
      "generate",
      "eslint",
      "--force",
    ]);
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("Generated eslint.config.js");

    // Verify file was overwritten with new content
    const newContent = await readFile(eslintPath, "utf-8");
    expect(newContent).toContain("// Generated by cmc");
    expect(newContent).toContain('"no-var": "error"');
    expect(newContent).toContain('"prefer-const": "error"');
    expect(newContent).toContain('"eqeqeq": "error"');
    expect(newContent).not.toContain("OLD CONFIG");
  });

  it("overwrites Ruff config when --force is used", async () => {
    // Verify original file has old content
    const ruffPath = join(forceOverwriteDir, "ruff.toml");
    const originalContent = await readFile(ruffPath, "utf-8");
    expect(originalContent).toContain("OLD CONFIG");
    expect(originalContent).toContain("line-length = 80");

    // Run generate with --force
    const result = await run("generate/force-overwrite", [
      "generate",
      "ruff",
      "--force",
    ]);
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("Generated ruff.toml");

    // Verify file was overwritten with new content from cmc.toml
    const newContent = await readFile(ruffPath, "utf-8");
    expect(newContent).toContain("# Generated by cmc");
    expect(newContent).toContain("line-length = 120");
    expect(newContent).toContain('select = ["E","F","I"]');
    expect(newContent).not.toContain("OLD CONFIG");
  });
});

describe("cmc generate - empty rulesets", () => {
  it("handles ESLint generation with no rules defined", async () => {
    const result = await run("generate/empty-ruleset", [
      "generate",
      "eslint",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("// Generated by cmc");
    expect(result.stdout).toContain("rules:");
  });

  it("handles Ruff generation with no config defined", async () => {
    const result = await run("generate/empty-ruleset", [
      "generate",
      "ruff",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("# Generated by cmc");
  });
});

// =============================================================================
// Generate: TypeScript (tsc)
// =============================================================================
describe("cmc generate tsc", () => {
  it("generates valid tsconfig.json with --stdout", async () => {
    const result = await run("generate/tsc/fresh", [
      "generate",
      "tsc",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    const config = JSON.parse(result.stdout);
    expect(config.$schema).toBe("https://json.schemastore.org/tsconfig");
    expect(config._comment).toContain("Generated by cmc");
  });

  it("includes compilerOptions from cmc.toml", async () => {
    const result = await run("generate/tsc/fresh", [
      "generate",
      "tsc",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    const config = JSON.parse(result.stdout);
    expect(config.compilerOptions.strict).toBe(true);
    expect(config.compilerOptions.noUncheckedIndexedAccess).toBe(true);
    expect(config.compilerOptions.noImplicitReturns).toBe(true);
  });

  it("includes essential defaults", async () => {
    const result = await run("generate/tsc/fresh", [
      "generate",
      "tsc",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    const config = JSON.parse(result.stdout);
    expect(config.compilerOptions.target).toBe("ES2020");
    expect(config.compilerOptions.module).toBe("ESNext");
    expect(config.compilerOptions.noEmit).toBe(true);
  });

  it("is case insensitive for linter name", async () => {
    const result = await run("generate/tsc/fresh", [
      "generate",
      "TSC",
      "--stdout",
    ]);

    expect(result.exitCode).toBe(0);
    const config = JSON.parse(result.stdout);
    expect(config.$schema).toBe("https://json.schemastore.org/tsconfig");
  });
});
