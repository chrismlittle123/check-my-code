# v1.8.0 PRD: Requirements & Tool Enforcement

## Overview

Version 1.8.0 implements requirements enforcement, allowing projects to define required files and tool configurations that must exist in the project. This enables organizations to enforce policy compliance across repositories without running the tools themselves.

## Problem Statement

Without requirements enforcement:

- Projects may be missing critical files (`CLAUDE.md`, `.nvmrc`, `CHANGELOG.md`)
- Security and quality tools may not be configured even if mandated by org policy
- No automated way to verify tool presence without running each tool
- Compliance checks are manual and inconsistent

With requirements enforcement:

- Required files are checked automatically during `cmc check` and `cmc audit`
- Tool configuration presence is verified (policy enforcer, not tool runner)
- Clear error messages identify exactly what's missing
- Organizations can define requirements centrally via `[extends]` (v1.6.x)

## Features

### 1. `[requirements.files]` Configuration

#### Description

Define an array of files that must exist in the project. These are checked relative to the project root (where `cmc.toml` lives).

#### Config Format

```toml
[project]
name = "my-project"

[requirements]
files = [
  "CLAUDE.md",
  ".nvmrc",
  "CHANGELOG.md",
  ".coderabbit.yaml",
  "knip.json"
]
```

#### File Path Formats

- Simple filenames: `"CLAUDE.md"` - checked at project root
- Nested paths: `".github/CODEOWNERS"` - checked relative to project root
- No glob patterns (exact paths only)

#### Examples

**Required files exist (success):**

```text
$ cmc check src/
✓ All required files present (5 files)
Running linters...
```

**Missing required files (failure):**

```text
$ cmc check src/
✗ Missing required files:
  - CLAUDE.md
  - .coderabbit.yaml

2 requirements failed
Exit code: 1
```

### 2. `[requirements.tools]` Configuration

#### Description

Enforce that specific tools are configured in the project. This is a **policy enforcer**, not a tool runner - it checks for the presence of tool configuration files, not whether the tools are installed or passing.

#### Supported Tools

| Tool        | Purpose                           | Config Files Checked                          |
| ----------- | --------------------------------- | --------------------------------------------- |
| `ty`        | Python type checking (Astral)     | `pyproject.toml` with `[tool.ty]`             |
| `gitleaks`  | Secrets detection                 | `.gitleaks.toml` or `.gitleaks.yaml`          |
| `npm-audit` | JS/TS dependency vulnerabilities  | `package.json` exists (npm audit available)   |
| `pip-audit` | Python dependency vulnerabilities | `pyproject.toml` or `requirements.txt` exists |
| `knip`      | TypeScript dead code detection    | `knip.json` or `knip.jsonc`                   |
| `vulture`   | Python dead code detection        | `pyproject.toml` with `[tool.vulture]`        |

#### Config Format

```toml
[project]
name = "my-project"

[requirements]
tools = ["gitleaks", "npm-audit", "knip"]
```

#### Tool Detection Logic

Each tool has specific detection logic:

**`ty`** (Astral's Python type checker):

- Check for `pyproject.toml` containing `[tool.ty]` section

**`gitleaks`** (secrets detection):

- Check for `.gitleaks.toml` OR `.gitleaks.yaml` OR `.gitleaks.yml`

**`npm-audit`** (JS/TS vulnerability scanning):

- Check for `package.json` (npm audit is built-in when package.json exists)

**`pip-audit`** (Python vulnerability scanning):

- Check for `pyproject.toml` OR `requirements.txt`

**`knip`** (TypeScript dead code):

- Check for `knip.json` OR `knip.jsonc` OR `knip.config.ts` OR `knip.config.js`
- OR `package.json` with `"knip"` key

**`vulture`** (Python dead code):

- Check for `pyproject.toml` containing `[tool.vulture]` section

#### Examples

**All tools configured (success):**

```
$ cmc check src/
✓ All required tools configured (3 tools)
Running linters...
```

**Missing tool configurations (failure):**

```
$ cmc check src/
✗ Missing tool configurations:
  - gitleaks: No .gitleaks.toml or .gitleaks.yaml found
  - knip: No knip.json or knip config found

2 tool requirements failed
Exit code: 1
```

### 3. Combined Requirements

#### Description

Both `files` and `tools` can be specified together. All requirements must pass for the check to succeed.

#### Config Format

```toml
[project]
name = "my-project"

[requirements]
files = ["CLAUDE.md", "CHANGELOG.md", ".nvmrc"]
tools = ["gitleaks", "npm-audit", "knip"]
```

#### Output Order

Requirements are checked and reported in this order:

1. Required files (if configured)
2. Required tools (if configured)
3. Linting (only if requirements pass, unless `--skip-requirements`)

### 4. CLI Support

#### `cmc check` Integration

Requirements are validated before running linters:

```bash
# Normal flow: requirements checked first
cmc check src/

# Skip requirements and only run linters
cmc check src/ --skip-requirements
```

#### `cmc audit` Integration

Requirements can be audited specifically:

```bash
# Audit includes requirements check
cmc audit

# Audit only requirements
cmc audit requirements

# Skip requirements in full audit
cmc audit --skip-requirements
```

#### New Flags

| Flag                  | Commands         | Description                  |
| --------------------- | ---------------- | ---------------------------- |
| `--skip-requirements` | `check`, `audit` | Skip requirements validation |

### 5. JSON Output

When `--json` flag is used, requirements results are included:

```json
{
  "requirements": {
    "files": {
      "required": ["CLAUDE.md", "CHANGELOG.md", ".nvmrc"],
      "missing": ["CLAUDE.md"],
      "passed": false
    },
    "tools": {
      "required": ["gitleaks", "npm-audit", "knip"],
      "missing": [
        {
          "tool": "gitleaks",
          "reason": "No .gitleaks.toml or .gitleaks.yaml found"
        }
      ],
      "passed": false
    },
    "passed": false
  },
  "violations": [],
  "summary": {
    "filesChecked": 0,
    "violationCount": 0,
    "exitCode": 1
  }
}
```

### 6. Inheritance Support

Requirements can be inherited from remote configs (using v1.6.x `[extends]` system):

#### Remote Requirements File

**`requirements/base/1.0.0.toml`:**

```toml
[requirements]
files = ["CLAUDE.md", "CHANGELOG.md"]
tools = ["gitleaks"]
```

#### Local Config

```toml
[project]
name = "my-project"

[extends]
requirements = "github:myorg/standards/requirements/base@v1.0.0"

# Local additions (merged with inherited)
[requirements]
files = [".nvmrc"]
tools = ["knip"]
```

#### Merge Behavior

| Scenario                       | Result                     |
| ------------------------------ | -------------------------- |
| Remote has file, local doesn't | File is required           |
| Local has file, remote doesn't | File is required           |
| Both have same file            | File is required (deduped) |
| Same for tools                 | Tools are merged (deduped) |

Note: Unlike rulesets, requirements use **additive merge** without conflict detection - having the same file/tool in both is fine.

## Technical Specifications

### New Files

- `src/requirements/index.ts` - Requirements validation logic
- `src/requirements/tools.ts` - Tool detection implementations

### Modified Files

- `src/types.ts` - Add `RequirementsConfig` interface
- `src/config/loader.ts` - Add `requirementsSchema` Zod validation
- `src/cli/commands/check.ts` - Integrate requirements check before linting
- `src/cli/commands/audit.ts` - Add `requirements` target option
- `schemas/cmc.schema.json` - Add requirements schema

### Types

```typescript
// In src/types.ts

// Supported tools for requirements.tools
export type RequiredTool =
  | "ty"
  | "gitleaks"
  | "npm-audit"
  | "pip-audit"
  | "knip"
  | "vulture";

// Requirements configuration
export interface RequirementsConfig {
  files?: string[];
  tools?: RequiredTool[];
}

// Extend Config interface
export interface Config {
  project: { name: string };
  extends?: ExtendsConfig;
  tools?: ToolsConfig;
  files?: FilesConfig;
  prompts?: AiContextConfig;
  requirements?: RequirementsConfig;  // NEW
  rulesets?: { ... };
}
```

```typescript
// In src/requirements/index.ts

export interface RequirementsCheckResult {
  files: {
    required: string[];
    missing: string[];
    passed: boolean;
  };
  tools: {
    required: string[];
    missing: ToolMissing[];
    passed: boolean;
  };
  passed: boolean;
}

export interface ToolMissing {
  tool: RequiredTool;
  reason: string;
}

export function checkRequirements(
  projectRoot: string,
  config: Config,
): RequirementsCheckResult;

export function hasRequirements(config: Config): boolean;
```

```typescript
// In src/requirements/tools.ts

export interface ToolChecker {
  name: RequiredTool;
  check: (
    projectRoot: string,
  ) => Promise<{ configured: boolean; reason?: string }>;
}

export const toolCheckers: Record<RequiredTool, ToolChecker>;
```

### Zod Schema Addition

```typescript
// In src/config/loader.ts

const requiredToolSchema = z.enum([
  "ty",
  "gitleaks",
  "npm-audit",
  "pip-audit",
  "knip",
  "vulture",
]);

const requirementsSchema = z
  .object({
    files: z.array(z.string().min(1)).min(1).optional(),
    tools: z.array(requiredToolSchema).min(1).optional(),
  })
  .strict();

// Add to configSchema
export const configSchema = z
  .object({
    project: z.object({ name: z.string().min(1) }).strict(),
    extends: extendsSchema.optional(),
    tools: toolsSchema.optional(),
    files: filesSchema.optional(),
    prompts: aiContextSchema.optional(),
    requirements: requirementsSchema.optional(),  // NEW
    rulesets: z.object({ ... }).strict().optional(),
  })
  .strict();
```

### Error Handling

| Error                       | Exit Code | Message                                            |
| --------------------------- | --------- | -------------------------------------------------- |
| Missing required file       | 1         | `Missing required files: {list}`                   |
| Missing tool configuration  | 1         | `Missing tool configurations: {list with reasons}` |
| Invalid tool name in config | 2         | `Invalid tool in requirements.tools: {name}`       |
| Empty requirements arrays   | 2         | `requirements.files must have at least 1 item`     |

### Integration Flow

```
cmc check src/
  ├── loadConfig()
  ├── If requirements configured AND NOT --skip-requirements:
  │     ├── checkRequirements(projectRoot, config)
  │     │     ├── Check files exist
  │     │     └── Check tools configured
  │     ├── If requirements failed:
  │     │     ├── Output failures
  │     │     └── Exit 1 (do not run linters)
  │     └── If requirements passed:
  │           └── Output success, continue
  ├── discoverFiles()
  ├── runLinters()
  └── outputResults()
```

## Testing

### Unit Tests

**`tests/unit/requirements.test.ts`:**

- Check required files exist
- Check required files missing
- Tool detection for each supported tool
- Empty config returns passed
- Mixed files and tools

**`tests/unit/config-loader.test.ts`:**

- Parse requirements.files array
- Parse requirements.tools array
- Reject invalid tool names
- Reject empty arrays

### E2E Tests

**`tests/e2e/requirements.test.ts`:**

- `cmc check` with all requirements passing
- `cmc check` with missing files
- `cmc check` with missing tools
- `cmc check --skip-requirements` bypasses check
- `cmc audit requirements` validates requirements
- JSON output includes requirements results
- Exit code 1 when requirements fail

### Test Fixtures

```
tests/e2e/projects/
├── check/
│   ├── requirements-pass/
│   │   ├── cmc.toml
│   │   ├── CLAUDE.md
│   │   ├── CHANGELOG.md
│   │   └── clean.ts
│   ├── requirements-missing-files/
│   │   ├── cmc.toml          # requires CLAUDE.md
│   │   └── clean.ts          # CLAUDE.md missing
│   ├── requirements-missing-tools/
│   │   ├── cmc.toml          # requires gitleaks
│   │   └── clean.ts          # no .gitleaks.toml
│   └── requirements-skip/
│       ├── cmc.toml          # requires files
│       └── clean.ts          # missing but --skip-requirements
├── audit/
│   └── requirements/
│       ├── pass/
│       │   └── cmc.toml
│       └── fail/
│           └── cmc.toml
└── validate/
    ├── valid-requirements/
    │   └── cmc.toml
    ├── invalid-requirements-tool/
    │   └── cmc.toml          # unknown tool name
    └── invalid-requirements-empty/
        └── cmc.toml          # empty array
```

## Rollout

1. Add `RequirementsConfig` interface to `src/types.ts`
2. Add `requirementsSchema` to `src/config/loader.ts`
3. Create `src/requirements/index.ts` with `checkRequirements()`
4. Create `src/requirements/tools.ts` with tool checkers
5. Integrate into `src/cli/commands/check.ts`
6. Add `--skip-requirements` flag to check command
7. Integrate into `src/cli/commands/audit.ts`
8. Add `--skip-requirements` flag to audit command
9. Update `schemas/cmc.schema.json`
10. Write unit tests
11. Write E2E tests
12. Update CHANGELOG.md
13. Release v1.8.0

## Out of Scope

The following are explicitly not part of v1.8.0:

- **Running tools** - This is a policy enforcer, not a tool runner; it checks for configuration, not tool output
- **Tool version requirements** - Not checking tool versions, only presence
- **Custom tool definitions** - Only the predefined tool list is supported
- **Glob patterns for files** - Only exact file paths are supported
- **Conditional requirements** - All requirements apply unconditionally
- **Per-directory requirements** - Requirements are project-wide only
