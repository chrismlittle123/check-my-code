# v1.9.0 PRD: Native Code Limits

## Overview

Version 1.9.0 implements native code complexity limits for Python and TypeScript. Unlike ESLint/Ruff which require external tool configuration, cmc checks these limits directly by parsing AST (Abstract Syntax Tree) to count lines, parameters, and nesting depth.

## Problem Statement

Without native code limits:

- Teams rely on scattered tool configurations (ESLint `max-lines-per-function`, Ruff complexity rules)
- Configuration varies across tools and languages with inconsistent semantics
- No unified way to enforce the same limits across Python and TypeScript
- Adding new complexity rules requires configuring multiple external tools

With native code limits:

- Single configuration in `cmc.toml` for both languages
- Consistent semantics across Python and TypeScript
- No external tool dependencies for complexity checks
- Violations reported in unified format alongside ESLint/Ruff/tsc violations

## Features

### 1. `[rulesets.limits]` Configuration

#### Description

Define code complexity limits that apply to both Python and TypeScript files. These are checked natively by cmc without requiring external tools.

#### Config Format

```toml
[project]
name = "my-project"

[rulesets.limits]
max_file_lines = 500
max_function_lines = 50
max_parameters = 5
max_nesting_depth = 4
```

#### Limit Definitions

| Limit                | Description                                      | Default  |
| -------------------- | ------------------------------------------------ | -------- |
| `max_file_lines`     | Maximum total lines per file (including blanks)  | disabled |
| `max_function_lines` | Maximum lines in a function/method body          | disabled |
| `max_parameters`     | Maximum parameters in function/method definition | disabled |
| `max_nesting_depth`  | Maximum nesting depth (if/for/while/try/with)    | disabled |

All limits are optional. If not specified, that limit is not enforced.

### 2. Python Implementation

#### AST Parsing

Use Python's `ast` module via a bundled Python script to extract:

- File line count
- Function/method definitions with line counts and parameter counts
- Nesting depth within functions

#### Detection Logic

**File lines:**

- Count total lines in file

**Function lines:**

- Parse `def` and `async def` statements
- Count lines from function start to end (inclusive)
- Include decorators in the line count

**Parameters:**

- Count positional args, keyword-only args, \*args, \*\*kwargs
- Exclude `self` and `cls` from the count

**Nesting depth:**

- Count levels of `if`, `for`, `while`, `try`, `with`, `match` blocks
- Track maximum depth reached within each function

#### Example Violations

```python
# max_function_lines = 50 violated
def process_data(items):  # Line 1
    # ... 60 lines of code ...
    pass  # Line 61
# Error: Function 'process_data' has 61 lines (max: 50)

# max_parameters = 5 violated
def create_user(name, email, age, role, dept, team, manager):
    pass
# Error: Function 'create_user' has 7 parameters (max: 5)

# max_nesting_depth = 4 violated
def nested():
    if a:           # depth 1
        for x in y:  # depth 2
            if b:    # depth 3
                while c:  # depth 4
                    if d:  # depth 5 - VIOLATION
                        pass
# Error: Function 'nested' has nesting depth 5 (max: 4)
```

### 3. TypeScript Implementation

#### AST Parsing

Use TypeScript compiler API via a bundled TS script to extract:

- File line count
- Function/method/arrow function definitions with line counts and parameter counts
- Nesting depth within functions

#### Detection Logic

**File lines:**

- Count total lines in file

**Function lines:**

- Parse `function`, method declarations, and arrow functions
- Count lines from function start to end
- Include decorators in the line count

**Parameters:**

- Count all parameters including rest parameters
- Exclude `this` parameter from the count

**Nesting depth:**

- Count levels of `if`, `for`, `while`, `do`, `switch`, `try` blocks
- Track maximum depth reached within each function

#### Example Violations

```typescript
// max_function_lines = 50 violated
function processData(items: Item[]): Result {  // Line 1
    // ... 60 lines of code ...
    return result;  // Line 61
}
// Error: Function 'processData' has 61 lines (max: 50)

// max_parameters = 5 violated
function createUser(
    name: string,
    email: string,
    age: number,
    role: string,
    dept: string,
    team: string,
    manager: string
): User { ... }
// Error: Function 'createUser' has 7 parameters (max: 5)

// Arrow functions also checked
const handler = (a: A, b: B, c: C, d: D, e: E, f: F) => { ... }
// Error: Arrow function has 6 parameters (max: 5)
```

### 4. CLI Integration

#### `cmc check` Integration

Limits are checked as part of the normal check flow:

```bash
# Limits checked along with ESLint/Ruff/tsc
cmc check src/

# Skip limits check (run only external linters)
cmc check src/ --skip-limits
```

#### Output Format

Violations are reported in the same format as other linters:

```text
src/utils.py:15:1: Function 'process_data' has 65 lines (max: 50) [limits/max-function-lines]
src/utils.py:82:1: Function 'create_user' has 7 parameters (max: 5) [limits/max-parameters]
src/handlers.ts:30:1: Function 'handleRequest' has nesting depth 5 (max: 4) [limits/max-nesting-depth]
src/large-file.ts:1:1: File has 600 lines (max: 500) [limits/max-file-lines]

4 violations found
```

### 5. JSON Output

When `--json` flag is used, limits violations are included with other violations:

```json
{
  "violations": [
    {
      "file": "src/utils.py",
      "line": 15,
      "column": 1,
      "message": "Function 'process_data' has 65 lines (max: 50)",
      "rule": "limits/max-function-lines",
      "severity": "error",
      "linter": "limits"
    },
    {
      "file": "src/handlers.ts",
      "line": 30,
      "column": 1,
      "message": "Function 'handleRequest' has nesting depth 5 (max: 4)",
      "rule": "limits/max-nesting-depth",
      "severity": "error",
      "linter": "limits"
    }
  ],
  "summary": {
    "filesChecked": 10,
    "violationCount": 4,
    "exitCode": 1
  }
}
```

### 6. Inheritance Support

Limits can be inherited from remote configs (using v1.6.x `[extends]` system):

#### Remote Limits File

**`rulesets/limits/1.0.0.toml`:**

```toml
[rulesets.limits]
max_file_lines = 500
max_function_lines = 50
max_parameters = 5
```

#### Local Config

```toml
[project]
name = "my-project"

[extends]
limits = "github:myorg/standards/rulesets/limits@v1.0.0"

# Local can make limits stricter but not looser
[rulesets.limits]
max_function_lines = 40  # Stricter than inherited 50
max_nesting_depth = 4    # New limit not in inherited
```

#### Merge Behavior

| Scenario                        | Result                         |
| ------------------------------- | ------------------------------ |
| Remote has limit, local doesn't | Remote limit applies           |
| Local has limit, remote doesn't | Local limit applies            |
| Both have same limit            | Stricter (lower) value wins    |
| Conflict (local looser)         | Error - local cannot be looser |

## Technical Specifications

### New Files

- `src/limits/index.ts` - Main limits checking logic
- `src/limits/types.ts` - Types for limits configuration and results
- `src/limits/python.ts` - Python AST parsing and limit checking
- `src/limits/typescript.ts` - TypeScript AST parsing and limit checking
- `scripts/python-limits.py` - Python script for AST analysis (bundled)

### Modified Files

- `src/types.ts` - Add `LimitsConfig` interface
- `src/config/loader.ts` - Add `limitsSchema` Zod validation
- `src/cli/commands/check.ts` - Integrate limits checking
- `src/linter/types.ts` - Add "limits" to linter type
- `schemas/cmc.schema.json` - Add limits schema

### Types

```typescript
// In src/limits/types.ts

export interface LimitsConfig {
  max_file_lines?: number;
  max_function_lines?: number;
  max_parameters?: number;
  max_nesting_depth?: number;
}

export interface LimitViolation {
  file: string;
  line: number;
  column: number;
  message: string;
  rule: LimitRule;
  functionName?: string; // For function-level violations
}

export type LimitRule =
  | "limits/max-file-lines"
  | "limits/max-function-lines"
  | "limits/max-parameters"
  | "limits/max-nesting-depth";

export interface FunctionInfo {
  name: string;
  startLine: number;
  endLine: number;
  lineCount: number;
  parameterCount: number;
  maxNestingDepth: number;
}

export interface FileAnalysis {
  filePath: string;
  totalLines: number;
  functions: FunctionInfo[];
}
```

```typescript
// In src/limits/index.ts

export function checkLimits(
  files: string[],
  config: LimitsConfig,
): Promise<LimitViolation[]>;

export function hasLimitsConfig(config: Config): boolean;
```

```typescript
// In src/limits/python.ts

export function analyzePythonFile(filePath: string): Promise<FileAnalysis>;
```

```typescript
// In src/limits/typescript.ts

export function analyzeTypeScriptFile(filePath: string): Promise<FileAnalysis>;
```

### Zod Schema Addition

```typescript
// In src/config/loader.ts

const limitsSchema = z
  .object({
    max_file_lines: z.number().int().positive().optional(),
    max_function_lines: z.number().int().positive().optional(),
    max_parameters: z.number().int().positive().optional(),
    max_nesting_depth: z.number().int().positive().optional(),
  })
  .strict()
  .refine((data) => Object.values(data).some((v) => v !== undefined), {
    message: "At least one limit must be specified",
  });

// Update rulesetsSchema
const rulesetsSchema = z
  .object({
    eslint: eslintSchema.optional(),
    ruff: ruffSchema.optional(),
    tsc: tscSchema.optional(),
    limits: limitsSchema.optional(), // NEW
  })
  .strict();
```

### Python AST Script

The Python limits checker is implemented as a standalone Python script that outputs JSON:

```python
#!/usr/bin/env python3
"""
python-limits.py - Analyze Python files for code limits.
Outputs JSON with file analysis data.
"""
import ast
import json
import sys

def analyze_file(filepath: str) -> dict:
    with open(filepath) as f:
        source = f.read()
        lines = source.splitlines()

    tree = ast.parse(source, filename=filepath)
    functions = []

    for node in ast.walk(tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            functions.append(analyze_function(node, lines))

    return {
        "filePath": filepath,
        "totalLines": len(lines),
        "functions": functions
    }

def analyze_function(node, lines) -> dict:
    # Count parameters (excluding self/cls)
    params = node.args
    param_count = (
        len([a for a in params.args if a.arg not in ('self', 'cls')]) +
        len(params.posonlyargs) +
        len(params.kwonlyargs) +
        (1 if params.vararg else 0) +
        (1 if params.kwarg else 0)
    )

    # Calculate nesting depth
    max_depth = calculate_nesting_depth(node)

    return {
        "name": node.name,
        "startLine": node.lineno,
        "endLine": node.end_lineno,
        "lineCount": node.end_lineno - node.lineno + 1,
        "parameterCount": param_count,
        "maxNestingDepth": max_depth
    }

def calculate_nesting_depth(node, current_depth=0) -> int:
    max_depth = current_depth
    nesting_nodes = (ast.If, ast.For, ast.While, ast.Try, ast.With, ast.Match)

    for child in ast.iter_child_nodes(node):
        if isinstance(child, nesting_nodes):
            child_depth = calculate_nesting_depth(child, current_depth + 1)
            max_depth = max(max_depth, child_depth)
        else:
            child_depth = calculate_nesting_depth(child, current_depth)
            max_depth = max(max_depth, child_depth)

    return max_depth

if __name__ == "__main__":
    results = [analyze_file(f) for f in sys.argv[1:]]
    print(json.dumps(results))
```

### TypeScript AST Analysis

Use the TypeScript compiler API directly in Node.js:

```typescript
// src/limits/typescript.ts
import ts from "typescript";
import { readFileSync } from "fs";
import type { FileAnalysis, FunctionInfo } from "./types.js";

export function analyzeTypeScriptFile(filePath: string): FileAnalysis {
  const source = readFileSync(filePath, "utf-8");
  const sourceFile = ts.createSourceFile(
    filePath,
    source,
    ts.ScriptTarget.Latest,
    true,
  );

  const functions: FunctionInfo[] = [];

  function visit(node: ts.Node) {
    if (
      ts.isFunctionDeclaration(node) ||
      ts.isMethodDeclaration(node) ||
      ts.isArrowFunction(node) ||
      ts.isFunctionExpression(node)
    ) {
      functions.push(analyzeFunctionNode(node, sourceFile));
    }
    ts.forEachChild(node, visit);
  }

  visit(sourceFile);

  return {
    filePath,
    totalLines: source.split("\n").length,
    functions,
  };
}

function analyzeFunctionNode(
  node: ts.FunctionLikeDeclaration,
  sourceFile: ts.SourceFile,
): FunctionInfo {
  const startLine =
    sourceFile.getLineAndCharacterOfPosition(node.getStart()).line + 1;
  const endLine =
    sourceFile.getLineAndCharacterOfPosition(node.getEnd()).line + 1;

  // Count parameters (excluding 'this' parameter)
  const params = node.parameters.filter(
    (p) => !ts.isIdentifier(p.name) || p.name.text !== "this",
  );

  // Get function name
  let name = "<anonymous>";
  if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node)) {
    name = node.name?.getText(sourceFile) ?? "<anonymous>";
  } else if (ts.isArrowFunction(node) || ts.isFunctionExpression(node)) {
    const parent = node.parent;
    if (ts.isVariableDeclaration(parent) && ts.isIdentifier(parent.name)) {
      name = parent.name.text;
    }
  }

  return {
    name,
    startLine,
    endLine,
    lineCount: endLine - startLine + 1,
    parameterCount: params.length,
    maxNestingDepth: calculateNestingDepth(node),
  };
}

function calculateNestingDepth(node: ts.Node, depth = 0): number {
  let maxDepth = depth;

  const isNestingNode = (n: ts.Node): boolean =>
    ts.isIfStatement(n) ||
    ts.isForStatement(n) ||
    ts.isForInStatement(n) ||
    ts.isForOfStatement(n) ||
    ts.isWhileStatement(n) ||
    ts.isDoStatement(n) ||
    ts.isSwitchStatement(n) ||
    ts.isTryStatement(n);

  ts.forEachChild(node, (child) => {
    const childDepth = isNestingNode(child)
      ? calculateNestingDepth(child, depth + 1)
      : calculateNestingDepth(child, depth);
    maxDepth = Math.max(maxDepth, childDepth);
  });

  return maxDepth;
}
```

### Error Handling

| Error                | Exit Code | Message                                              |
| -------------------- | --------- | ---------------------------------------------------- |
| Limit violated       | 1         | Standard violation output                            |
| Invalid limit value  | 2         | `Invalid limit value: max_file_lines must be > 0`    |
| Python not available | 3         | `Python 3 required for limits checking on .py files` |
| Parse error          | 3         | `Failed to parse {file}: {error}`                    |

### Integration Flow

```
cmc check src/
  ├── loadConfig()
  ├── If requirements configured: checkRequirements()
  ├── discoverFiles()
  ├── If limits configured AND NOT --skip-limits:
  │     ├── Filter .py and .ts/.tsx files
  │     ├── For .py files: run python-limits.py script
  │     ├── For .ts files: use TypeScript compiler API
  │     ├── Check each file against limits
  │     └── Collect violations
  ├── runLinters() (ESLint, Ruff, tsc)
  ├── Merge all violations
  └── outputResults()
```

## Testing

### Unit Tests

**`tests/unit/limits.test.ts`:**

- Parse Python file and extract function info
- Parse TypeScript file and extract function info
- Check max_file_lines violation
- Check max_function_lines violation
- Check max_parameters violation
- Check max_nesting_depth violation
- Multiple violations in single file
- No violations when within limits
- Skip files without configured limits
- Handle syntax errors gracefully

### E2E Tests

**`tests/e2e/limits.test.ts`:**

- `cmc check` with all limits passing
- `cmc check` with max_file_lines violation
- `cmc check` with max_function_lines violation
- `cmc check` with max_parameters violation
- `cmc check` with max_nesting_depth violation
- `cmc check --skip-limits` bypasses check
- JSON output includes limits violations
- Mixed Python and TypeScript violations
- Limits combined with ESLint/Ruff violations

### Test Fixtures

```
tests/e2e/projects/
├── check/
│   ├── limits-pass/
│   │   ├── cmc.toml
│   │   ├── small-file.ts
│   │   └── clean.py
│   ├── limits-file-lines/
│   │   ├── cmc.toml          # max_file_lines = 50
│   │   └── large-file.ts     # 100 lines
│   ├── limits-function-lines/
│   │   ├── cmc.toml          # max_function_lines = 20
│   │   ├── long-function.ts  # function with 30 lines
│   │   └── long-function.py  # function with 30 lines
│   ├── limits-parameters/
│   │   ├── cmc.toml          # max_parameters = 4
│   │   ├── many-params.ts    # function with 6 params
│   │   └── many-params.py    # function with 6 params
│   ├── limits-nesting/
│   │   ├── cmc.toml          # max_nesting_depth = 3
│   │   ├── deep-nesting.ts   # depth of 5
│   │   └── deep-nesting.py   # depth of 5
│   └── limits-skip/
│       ├── cmc.toml          # has limits
│       └── violation.ts      # has violation but --skip-limits used
```

## Rollout

1. Add `LimitsConfig` interface to `src/types.ts`
2. Add `limitsSchema` to `src/config/loader.ts`
3. Create `src/limits/types.ts` with types
4. Create `src/limits/python.ts` with Python analysis
5. Create `src/limits/typescript.ts` with TypeScript analysis
6. Create `src/limits/index.ts` with main checking logic
7. Bundle `scripts/python-limits.py` for Python AST analysis
8. Integrate into `src/cli/commands/check.ts`
9. Add `--skip-limits` flag to check command
10. Add "limits" to linter type in `src/linter/types.ts`
11. Update `schemas/cmc.schema.json`
12. Write unit tests
13. Write E2E tests
14. Update CHANGELOG.md
15. Release v1.9.0

## Out of Scope

The following are explicitly not part of v1.9.0:

- **Cyclomatic complexity** - Only structural limits, not complexity metrics
- **Class limits** - Only function/method limits, not class-level
- **Import limits** - Not counting imports
- **Cognitive complexity** - Simpler nesting depth instead
- **Auto-fix** - Limits violations cannot be auto-fixed
- **Custom limit rules** - Only the predefined limits are supported
- **Per-directory limits** - Limits are project-wide only
- **Language-specific limits** - Same limits apply to both Python and TypeScript

## Future Considerations

For potential future versions:

- `max_class_lines` - Maximum lines per class
- `max_imports` - Maximum import statements per file
- `cyclomatic_complexity` - McCabe complexity metric
- Per-file overrides via comments (`# cmc: max-function-lines=100`)
- Language-specific limit values
