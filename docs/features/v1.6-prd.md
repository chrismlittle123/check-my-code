# v1.6.0 PRD: Remote Config Inheritance

## Overview

Version 1.6.0 implements remote ruleset inheritance, allowing projects to extend base configurations from remote git repositories. This enables organizations to maintain centralized coding standards that projects can inherit and optionally extend.

## Problem Statement

Without remote config inheritance:

- Each repo has its own `cmc.toml` with its own rules
- Org-wide rule changes require manually updating every repo
- No enforcement prevents teams from weakening standards
- No version control for ruleset rollouts

With remote config inheritance:

- Base rules live in one central repository
- Projects inherit them automatically via `[extends]`
- Conflict detection prevents weakening inherited rules
- Version pinning enables controlled rollouts

## Current State

The codebase already has:

- `[extends]` schema defined in `src/config/loader.ts` (lines 79-92)
- Remote fetcher in `src/remote/fetcher.ts` supporting `github:owner/repo/path@version`
- `rulesets.json` manifest format in private repo with version resolution
- Partial TOML ruleset files (e.g., `[rulesets.eslint.rules]` only)

What's missing:

- Runtime resolution of `[extends]` references
- Fetching and parsing remote ruleset files
- Merging remote rules with local rules
- Conflict detection and error reporting
- Integration with `check`, `generate`, and `audit` commands

## Features

### 1. Remote Ruleset Resolution

#### Description

When loading `cmc.toml`, resolve `[extends]` references by fetching remote ruleset files and merging them with local configuration.

#### Config Format

```toml
[project]
name = "my-project"

[extends]
eslint = "github:myorg/standards/rulesets/internal/typescript/5.5/eslint@latest"
tsc = "github:myorg/standards/rulesets/internal/typescript/5.5/tsc@latest"
ruff = "github:myorg/standards/rulesets/internal/python/3.12/ruff@v1.0.0"

# Local rules are merged with inherited rules
[rulesets.eslint.rules]
"my-project-specific-rule" = "error"
```

#### Remote File Format

Remote files are partial `cmc.toml` files containing only the relevant ruleset section:

**`rulesets/internal/typescript/5.5/eslint/1.0.0.toml`:**

```toml
[rulesets.eslint.rules]
"no-var" = "error"
"prefer-const" = "error"
"eqeqeq" = "error"
"@typescript-eslint/no-explicit-any" = "warn"
```

**`rulesets/internal/typescript/5.5/tsc/1.0.0.toml`:**

```toml
[rulesets.tsc]
strict = true
```

#### Version Resolution

The remote reference format is: `github:owner/repo/path@version`

Where `path` points to a ruleset directory and `version` specifies which version to use.

**Version types:**

| Version   | Resolution                                                    | Use Case                |
| --------- | ------------------------------------------------------------- | ----------------------- |
| `@latest` | Lookup in `rulesets.json` manifest, resolve to latest version | Always use newest rules |
| `@1.0.0`  | Lookup in `rulesets.json` manifest, resolve specific version  | Pin to specific version |

**Note:** All version resolution goes through the `rulesets.json` manifest. The manifest is **required** - repos without a valid `rulesets.json` will error.

**Resolution flow:**

```
extends.eslint = "github:myorg/repo/rulesets/internal/typescript/5.5/eslint@latest"

1. Clone/fetch repo (default branch)
2. Read rulesets/rulesets.json (error if missing)
3. Find entry for "internal/typescript/5.5/eslint" (error if missing)
4. Resolve version:
   - If "@latest": use manifest's "latest" pointer (e.g., "1.0.0")
   - If "@1.0.0": use "1.0.0" from manifest versions (error if not found)
5. Get file path from manifest: versions["1.0.0"].file
6. Fetch the file (e.g., internal/typescript/5.5/eslint/1.0.0.toml)
7. Parse and return [rulesets.eslint.rules]
```

**Example `rulesets.json` structure:**

```json
{
  "schema_version": "1.0.0",
  "rulesets": {
    "internal/typescript/5.5/eslint": {
      "tier": "internal",
      "tool": "eslint",
      "versions": {
        "1.0.0": { "file": "internal/typescript/5.5/eslint/1.0.0.toml" },
        "1.0.1": { "file": "internal/typescript/5.5/eslint/1.0.1.toml" },
        "latest": "1.0.1"
      }
    }
  }
}
```

### 2. Rule Merging

#### Description

Merge inherited rules with local rules. Local rules can add new rules but cannot conflict with inherited rules. **Any conflict is an error** - this applies to all linter types (ESLint, Ruff, TSC).

#### Merge Behavior

| Scenario                                | Result                  |
| --------------------------------------- | ----------------------- |
| Remote has setting, local doesn't       | Use remote setting      |
| Local has setting, remote doesn't       | Use local setting       |
| Both have same setting, same value      | Use value (no conflict) |
| Both have same setting, different value | **Error**               |

#### Tool-Specific Merging

**ESLint (`[rulesets.eslint.rules]`):**

- Each rule key is compared independently
- Conflict: `"no-console": "error"` vs `"no-console": "warn"`

**Ruff (`[rulesets.ruff]`):**

- All settings are compared: `line-length`, `lint.select`, `lint.ignore`, etc.
- Conflict: `line-length = 100` vs `line-length = 120`
- Conflict: `lint.select = ["E", "F"]` vs `lint.select = ["E"]`

**TSC (`[rulesets.tsc]`):**

- All boolean flags are compared: `strict`, `noUncheckedIndexedAccess`, etc.
- Conflict: `strict = true` vs `strict = false`

#### Conflict Detection

When a local setting conflicts with an inherited setting, the CLI errors with a clear message:

```
Error: Config conflict detected

  Setting: "no-console" (eslint)
  Inherited value: "error"
  Local value: "warn"
  Source: github:myorg/standards/rulesets/typescript@1.0.0

Local config cannot override inherited config.
To resolve: remove "no-console" from local [rulesets.eslint.rules]
```

Exit code: 2 (configuration error)

#### Network Requirements

Remote fetching requires network access. If the remote repository cannot be reached:

- **Hard fail** with exit code 3 (network error)
- No fallback to stale cache
- User must have network access to use `[extends]`

### 3. Command Integration

#### `cmc check`

Before running linters:

1. Load local `cmc.toml`
2. If `[extends]` present, fetch and resolve remote rulesets
3. Merge remote and local rules (error on conflict)
4. Use merged config to run linters

#### `cmc generate`

Before generating config files:

1. Load and resolve config (same as check)
2. Generate config files using merged rules
3. Include comment in generated file indicating inheritance:

```javascript
// Generated by cmc - extends github:myorg/standards/rulesets/typescript@v1.0.0
export default [
  // ... merged rules
];
```

#### `cmc audit`

When auditing config files:

1. Load and resolve config (same as check)
2. Compare existing config against merged rules
3. Report mismatches against the full merged ruleset

### 4. Caching

Remote repositories are already cached in `~/.cmc/cache/` by the existing `fetcher.ts`.

For branch references like `@main`:

- Fetch on first use in a session
- Cache for subsequent calls in same session
- User can clear cache with `cmc cache clear` (future feature)

For tag/commit references like `@v1.0.0`:

- Cache indefinitely (immutable reference)

## Technical Specifications

### New Files

- `src/remote/rulesets.ts` - Ruleset fetching and resolution logic

### Modified Files

- `src/config/loader.ts` - Add `resolveExtends()` function, modify `loadConfig()` to call it
- `src/cli/commands/check.ts` - Use resolved config
- `src/cli/commands/generate.ts` - Use resolved config, add inheritance comment
- `src/cli/commands/audit.ts` - Use resolved config

### Types

```typescript
// In src/types.ts or src/remote/rulesets.ts

interface RulesetsManifest {
  schema_version: string;
  rulesets: Record<string, RulesetEntry>;
}

interface RulesetEntry {
  tier: "prototype" | "internal" | "production";
  description: string;
  tool: "eslint" | "ruff" | "tsc";
  format: "toml";
  versions: {
    [version: string]: { file: string } | string; // string for "latest" pointing to version
  };
}

interface ResolvedRuleset {
  source: string; // Original remote reference
  tool: "eslint" | "ruff" | "tsc";
  rules: Record<string, unknown>; // Parsed rules from remote file
}

class RuleConflictError extends Error {
  rule: string;
  inheritedValue: unknown;
  localValue: unknown;
  source: string;
}
```

### Resolution Flow

```
loadConfig(projectRoot)
  ├── Parse cmc.toml
  ├── If extends.eslint exists:
  │     ├── parseRemoteRef(extends.eslint)
  │     ├── fetchRemoteFile(ref, "rulesets.json")
  │     ├── resolveVersion(manifest, path)
  │     ├── fetchRemoteFile(ref, resolved_file)
  │     ├── Parse TOML, extract [rulesets.eslint.rules]
  │     └── Store as inheritedRules.eslint
  ├── If extends.tsc exists:
  │     └── (same flow for tsc)
  ├── If extends.ruff exists:
  │     └── (same flow for ruff)
  ├── mergeRules(inheritedRules, localRules)
  │     └── Throw RuleConflictError on conflicts
  └── Return merged config
```

### Error Handling

| Error                  | Exit Code | Message                                               |
| ---------------------- | --------- | ----------------------------------------------------- |
| Remote repo not found  | 2         | `Failed to fetch remote config: repository not found` |
| Manifest missing       | 2         | `Remote repository missing rulesets.json manifest`    |
| Manifest invalid       | 2         | `Invalid rulesets.json manifest: {error}`             |
| Manifest entry missing | 2         | `Ruleset not found in manifest: {path}`               |
| Version not found      | 2         | `Version not found: {version} for {path}`             |
| Remote file not found  | 2         | `Remote ruleset file not found: {path}`               |
| Invalid remote TOML    | 2         | `Invalid TOML in remote ruleset: {error}`             |
| Config conflict        | 2         | Detailed conflict message (see above)                 |
| Git not available      | 2         | `git is not installed or not in PATH`                 |
| Network error          | 3         | `Failed to fetch remote config: {error}`              |

## Testing

### Unit Tests

**`tests/unit/rulesets.test.ts`:**

- Parse rulesets.json manifest
- Resolve version from manifest (latest, specific version)
- Merge rules (no conflict)
- Merge rules (conflict detection)
- Error handling for missing entries

**`tests/unit/config-loader.test.ts`:**

- Load config with extends (mocked fetcher)
- Merge inherited and local rules
- Conflict detection

### E2E Tests

**`tests/e2e/extends.test.ts`:**

- `cmc check` with extends (requires test remote repo or mock)
- `cmc generate` with extends
- `cmc audit` with extends
- Conflict error output

### Test Fixtures

Create test fixtures in `tests/e2e/projects/extends/`:

```
extends/
├── cmc.toml          # Config with [extends]
├── local-override/
│   └── cmc.toml      # Config with conflicting local rule (for error test)
```

## Rollout

1. Implement `src/remote/rulesets.ts` with manifest parsing and version resolution
2. Add `resolveExtends()` to `src/config/loader.ts`
3. Add rule merging with conflict detection
4. Update `check` command to use resolved config
5. Update `generate` command to use resolved config
6. Update `audit` command to use resolved config
7. Add unit tests
8. Add E2E tests
9. Update CHANGELOG.md
10. Release v1.6.0

## Out of Scope

The following are explicitly not part of v1.6.0:

- **`cmc context` command** - No changes to context command; it does not use `[extends]`
- **`cmc cache clear` command** - Future feature for cache management
- **Nested inheritance** - Base config extending another base (deferred to v3.0.x)
- **Multiple inheritance per linter** - e.g., extending two ESLint configs (deferred to v3.0.x)
- **Override mechanism** - Intentionally differing from base config (future feature)
- **Offline mode** - Falling back to stale cache when network unavailable
- **Community registry** - Public registry of rulesets (separate feature)
