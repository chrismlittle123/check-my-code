import { Command } from "commander";
import { existsSync } from "fs";
import { writeFile } from "fs/promises";
import { join } from "path";
import {
  loadConfig,
  findProjectRoot,
  ConfigError,
} from "../../config/loader.js";
import { ExitCode, type Config } from "../../types.js";

type LinterTarget = "eslint" | "ruff" | "tsc";

const LINTER_CONFIGS: Record<
  LinterTarget,
  { filename: string; generator: (config: Config) => string }
> = {
  eslint: {
    filename: "eslint.config.js",
    generator: generateESLintConfig,
  },
  ruff: {
    filename: "ruff.toml",
    generator: generateRuffConfig,
  },
  tsc: {
    filename: "tsconfig.json",
    generator: generateTscConfig,
  },
};

export const generateCommand = new Command("generate")
  .description("Generate linter config files from cmc.toml ruleset")
  .argument("<linter>", "Linter to generate config for (eslint, ruff, tsc)")
  .option("--force", "Overwrite existing config file", false)
  .option("--stdout", "Output to stdout instead of file", false)
  .addHelpText(
    "after",
    `
Examples:
  $ cmc generate eslint          Generate eslint.config.js
  $ cmc generate ruff            Generate ruff.toml
  $ cmc generate tsc             Generate tsconfig.json
  $ cmc generate eslint --force  Overwrite existing config
  $ cmc generate eslint --stdout Preview config without writing`,
  )
  .action(
    async (linter: string, options: { force?: boolean; stdout?: boolean }) => {
      try {
        const target = validateLinterTarget(linter);
        const projectRoot = findProjectRoot();
        const config = await loadConfig(projectRoot);

        const { filename, generator } = LINTER_CONFIGS[target];
        const content = generator(config);

        if (options.stdout) {
          console.log(content);
          process.exit(ExitCode.SUCCESS);
        }

        const outputPath = join(projectRoot, filename);

        if (existsSync(outputPath) && !options.force) {
          console.error(
            `Error: ${filename} already exists. Use --force to overwrite.`,
          );
          process.exit(ExitCode.CONFIG_ERROR);
        }

        await writeFile(outputPath, content, "utf-8");
        console.log(`âœ“ Generated ${filename}`);
        process.exit(ExitCode.SUCCESS);
      } catch (error) {
        console.error(
          `Error: ${error instanceof Error ? error.message : "Unknown error"}`,
        );
        if (error instanceof ConfigError) {
          process.exit(ExitCode.CONFIG_ERROR);
        }
        process.exit(ExitCode.RUNTIME_ERROR);
      }
    },
  );

function validateLinterTarget(linter: string): LinterTarget {
  const normalized = linter.toLowerCase();
  if (
    normalized !== "eslint" &&
    normalized !== "ruff" &&
    normalized !== "tsc"
  ) {
    throw new Error(
      `Unknown linter: ${linter}. Supported linters: eslint, ruff, tsc`,
    );
  }
  return normalized;
}

function generateESLintConfig(config: Config): string {
  const rules = config.rulesets?.eslint?.rules ?? {};
  const hasRules = Object.keys(rules).length > 0;

  let rulesBlock: string;
  if (hasRules) {
    const rulesJson = JSON.stringify(rules, null, 2);
    // Indent each line (except first) by 4 spaces to align inside the rules object
    const lines = rulesJson.split("\n");
    rulesBlock = `${lines[0]}\n${lines
      .slice(1)
      .map((line) => `    ${line}`)
      .join("\n")}`;
  } else {
    rulesBlock = "{}";
  }

  return `// Generated by cmc (check-my-code)
// Do not edit manually - regenerate with: cmc generate eslint

import js from '@eslint/js';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  js.configs.recommended,
  ...tseslint.configs.recommended,
  {
    rules: ${rulesBlock},
  }
);
`;
}

function generateRuffConfig(config: Config): string {
  const ruffConfig = config.rulesets?.ruff;
  const lines: string[] = [
    "# Generated by cmc (check-my-code)",
    "# Do not edit manually - regenerate with: cmc generate ruff",
    "",
  ];

  if (!ruffConfig) {
    lines.push("# No ruff configuration defined in cmc.toml");
    return `${lines.join("\n")}\n`;
  }

  // Top-level options
  if (ruffConfig["line-length"] !== undefined) {
    lines.push(`line-length = ${ruffConfig["line-length"]}`);
  }

  // [lint] section
  if (ruffConfig.lint) {
    lines.push("");
    lines.push("[lint]");

    if (ruffConfig.lint.select && ruffConfig.lint.select.length > 0) {
      lines.push(`select = ${JSON.stringify(ruffConfig.lint.select)}`);
    }

    if (ruffConfig.lint.ignore && ruffConfig.lint.ignore.length > 0) {
      lines.push(`ignore = ${JSON.stringify(ruffConfig.lint.ignore)}`);
    }
  }

  return `${lines.join("\n")}\n`;
}

function generateTscConfig(config: Config): string {
  const tscConfig = config.rulesets?.tsc;

  // Build compilerOptions from cmc.toml settings
  const compilerOptions: Record<string, unknown> = {
    // Essential defaults for modern TypeScript
    target: "ES2020",
    module: "ESNext",
    moduleResolution: "node",
    esModuleInterop: true,
    skipLibCheck: true,
    noEmit: true,
  };

  if (tscConfig) {
    // Add strict type-checking options from cmc.toml
    const booleanOptions = [
      "strict",
      "noImplicitAny",
      "strictNullChecks",
      "strictFunctionTypes",
      "strictBindCallApply",
      "strictPropertyInitialization",
      "noImplicitThis",
      "alwaysStrict",
      "noUncheckedIndexedAccess",
      "noImplicitReturns",
      "noFallthroughCasesInSwitch",
      "noUnusedLocals",
      "noUnusedParameters",
      "exactOptionalPropertyTypes",
      "noImplicitOverride",
      "allowUnusedLabels",
      "allowUnreachableCode",
    ] as const;

    for (const option of booleanOptions) {
      if (tscConfig[option] !== undefined) {
        compilerOptions[option] = tscConfig[option];
      }
    }
  }

  const output = {
    $schema: "https://json.schemastore.org/tsconfig",
    _comment:
      "Generated by cmc (check-my-code) - regenerate with: cmc generate tsc",
    compilerOptions,
    include: ["src/**/*"],
    exclude: ["node_modules", "dist"],
  };

  return `${JSON.stringify(output, null, 2)}\n`;
}
